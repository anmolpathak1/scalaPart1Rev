package part4PatternMatching


import lectures.part2oop.MyList
import lectures.part2oop.Cons
import lectures.part2oop.Empty

object AllThePatterns extends App{
//  //1 - constants
//  val x : Any = "Scala"
//  val constants = x match {
//    case 1 => "a number"
//    case "Scala" => "The Scala."
//    case true => "the truth."
//    case AllThePatterns => "A singleton object."
//  }
//
//  //2 - match anything
//  //2.1 wildcard
//  val matchAnything = x match{
//    case _ =>
//  }
//
//  //2.2 variable
//  val matchVariable = x match{
//    case something => s" I have found $something"
//  }
//
//  //3 - tuples
//  val atuple = (1,2)
//  val matchATuple = atuple match {
//    case (1,1) =>
//    case (something,2) => s"I have found $something "
//  }
//
//  val nestedTuple = (1,(2,3))
//  val matchNestedTuple = nestedTuple match{
//    case (_, (2,v)) =>
//  }
//
//  //4 - case classes - constructor pattern.
//  val aList : MyList[Int] = Cons(1,Cons(2,Empty))
//  val matchAList = aList match{
//    case Empty =>
////    case Cons(head,tail) =>
//    case Cons(head,Cons(subhead,subtail)) =>
//  }
//
//  //5 - list patterns
//  val aStandardList = List(1,2,3,4)
//
//  val standardListMatching = aStandardList match{
//    case List(1,_,_,_) =>
//    case List(1,_* ) => // List of arbitrary length
//    case 1 :: List(_) => // infix pattern
//    case List(1,2,3) :+ 23 => //infix pattern
//  }
//
//  //6 - type specifiers.
//  val unknown : Any = 2
//  val unknownMatch = unknown match {
//    case list : List[Int] => //explicit type specifier
//    case _ =>
//  }
//
//  // 7 - name binding
//  val nameBindingMatch =  aList match{
//    case nonEmptyList @ Cons(_,_) =>
//    case Cons(1,rest @ Cons(2,_)) =>
//  }
//
//  //8  - multipatterns
//
//  val multipattern = aList match {
//    case Empty | Cons(0,_) =>
//  }

  
}
